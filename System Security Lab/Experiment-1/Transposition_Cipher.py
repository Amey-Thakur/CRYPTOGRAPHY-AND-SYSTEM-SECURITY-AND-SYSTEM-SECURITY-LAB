# Experiment 1: Product Cipher (Substitution & Transposition)
# Course: System Security Lab (CSL604)
# Name: Amey Thakur (https://github.com/Amey-Thakur)
# Roll No: 50
# Batch: B3
# Repository: https://github.com/Amey-Thakur/CRYPTOGRAPHY-AND-SYSTEM-SECURITY-AND-SYSTEM-SECURITY-LAB
# Date: 29/01/2021

"""
Theory:
Transposition Cipher is a cryptographic algorithm where the order of characters 
in the plaintext is rearranged to form the ciphertext. The actual characters 
are not changed, only their position.

This program demonstrates the Columnar Transposition technique, where the message
is written out in rows of a fixed length, and then read out column by column, 
typically according to a keyword.
"""

# Python3 implementation of Columnar Transposition 
import math 

key = "MEGA"

# Encryption 
def encryptMessage(msg): 
    """
    Encrypts the message using Columnar Transposition Cipher.
    
    Logic:
    1. The message is written into a grid (matrix) where the number of columns is the length of the key.
    2. Empty spaces in the last row are padded with underscores ('_').
    3. The ciphertext is generated by reading columns in the order determined by the alphabetical sorting of the key.
    
    Args:
        msg (str): The plaintext message.
        
    Returns:
        str: The encrypted ciphertext.
    """
    cipher = "" 

    # track key indices 
    k_indx = 0

    msg_len = float(len(msg)) 
    msg_lst = list(msg) 
    key_lst = sorted(list(key)) 

    # calculate column of the matrix (determined by key length)
    col = len(key) 
    
    # calculate maximum row of the matrix needed to fit the message
    row = int(math.ceil(msg_len / col)) 

    # Padding:
    # If the message does not perfectly fill the grid, calculate missing characters
    # and fill them with underscores ('_') to complete the matrix.
    fill_null = int((row * col) - msg_len) 
    msg_lst.extend('_' * fill_null) 

    # Matrix Construction:
    # Create the matrix by slicing the message list into chunks of size 'col'.
    # This represents writing the message row by row.
    matrix = [msg_lst[i: i + col] 
            for i in range(0, len(msg_lst), col)] 

    # Reading Column-wise:
    # Iterate through the columns. The order of columns read is determined by 
    # the alphabetical order of the characters in the 'key'.
    for _ in range(col): 
        # Find the index of the current key character in the original key string
        curr_idx = key.index(key_lst[k_indx]) 
        
        # Slicing: Append the column characters to the cipher string
        cipher += ''.join([row[curr_idx] 
                        for row in matrix]) 
        k_indx += 1

    return cipher 

# Decryption 
def decryptMessage(cipher): 
    """
    Decrypts the ciphertext using Columnar Transposition Cipher.
    
    Logic:
    1. The recipient knows the key and thus the number of columns and rows.
    2. An empty matrix is created.
    3. The ciphertext is filled into the matrix column by column, following the key's alphabetical order.
    4. The plaintext is then reconstructed by reading the matrix row by row.
    5. Any padding characters ('_') are removed.
    
    Args:
        cipher (str): The encrypted ciphertext.
        
    Returns:
        str: The decrypted plaintext.
    """
    msg = "" 

    # track key indices 
    k_indx = 0

    # track msg indices 
    msg_indx = 0
    msg_len = float(len(cipher)) 
    msg_lst = list(cipher) 

    # calculate column of the matrix 
    col = len(key) 
    
    # calculate maximum row of the matrix 
    row = int(math.ceil(msg_len / col)) 

    # convert key into list and sort alphabetically 
    # to determine the order in which columns were populated
    key_lst = sorted(list(key)) 

    # create an empty matrix to store deciphered message 
    dec_cipher = [] 
    for _ in range(row): 
        dec_cipher += [[None] * col] 

    # Matrix Filling:
    # Fill the matrix column-wise according to the key's sort order.
    # We take chunks of the ciphertext (length = row) and place them into the correct column index.
    for _ in range(col): 
        curr_idx = key.index(key_lst[k_indx]) 

        for j in range(row): 
            dec_cipher[j][curr_idx] = msg_lst[msg_indx] 
            msg_indx += 1
        k_indx += 1

    # Reconstruction:
    # Convert the matrix back into a string by reading it row-wise.
    try: 
        msg = ''.join(sum(dec_cipher, [])) 
    except TypeError: 
        raise TypeError("This program cannot", 
                        "handle repeating words.") 

    # Remove Padding:
    # Strip the underscores added regarding the encryption process.
    null_count = msg.count('_') 

    if null_count > 0: 
        return msg[: -null_count] 

    return msg 

# Driver Code 
if __name__ == "__main__":
    msg = "Amey Thakur"
    print("Original Message: " + msg)

    cipher = encryptMessage(msg) 
    print("Encrypted Message: {}".format(cipher)) 

    print("Decryped Message: {}".format(decryptMessage(cipher))) 
 
